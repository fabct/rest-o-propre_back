/**
 * Table Client
 * @typedef {object} Client 
 * @property {string?} id id généré par mongodb
 * @property {string} first Prenom du client
 * @property {string} last Nom du client
 * @property {string} pseudo
 * @property {number} age
 * @property {string} email 
 * @property {string} password MDP du client en haché 
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Restaurant
 * @typedef {object} Resto
 * @property {string?} id id généré par mongodb
 * @property {string} name Nom de l'établissement
 * @property {string} adress Adresse de l'établissement
 * @property {string} description_resto Description de l'établissement
 * @property {string} type le type de restaurant exemple: italien
 * @property {string} email Email de l'etablissement
 * @property {string} password Mot de passe de l'établissement
 * @property {string} first_prop Prenom proprio
 * @property {string} last_prop Nom du proprio
 * @property {string} siret Numéro du siret
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Note
 * @typedef {object} Note
 * @property {string?} id id généré par mongodb
 * @property {string} resto_id id du rétaurant concerné par la note
 * @property {string} client_id id du client qui à mis la note
 * @property {number} note_vaisselle 
 * @property {number} note_proprete
 * @property {number} note_soin
 * @property {string} comment
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Favoris
 * @typedef {object} Favoris
 * @property {string?} id
 * @property {string} resto_id
 * @property {string} client_id
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table produit
 * @typedef {object} Product
 * @property {string?} id id généré par mongodb
 * @property {string} resto_id id du restaurant
 * @property {string} name_product
 * @property {string} dlc
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Inspection Sanitaire
 * @typedef {object} Inspection_sanitaire
 * @property {string?} id
 * @property {string} resto_id
 * @property {string} date
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Objectif
 * @typedef {object} Objectif
 * @property {string?} id
 * @property {string} inspection_id
 * @property {string} description
 * @property {string?} created_at The date of creation (generated by business)
 */

//----- Importation des modules --------//

const data = require("../Data/data");
const client_checker = {
    first: /^[A-Za-z-]+$/,
    last: /^[A-Za-z-]+$/,
    pseudo : /^.+$/,
    age : /^[0-9]+$/,
    email: /^[^\s@]+@([^\s@.,]+\.)+[^\s@.,]{2,3}$/,
    password: /^.{8,}$/
};

const resto_checker = {
    name : /^[A-Za-z-]+$/,
    adress: /^[A-Za-z0-9]+$/,
    email: /^[^\s@]+@([^\s@.,]+\.)+[^\s@.,]{2,3}$/,
    type:/^[0-9]+$/,
    password:/^.{8,}$/,
    description_resto: /^.+$/,
    first_prop:/^[A-Za-z-]+$/,
    last_prop:/^[A-Za-z-]+$/,
    siret:/^[0-9]{14}$/
};

const note_checker = {
    resto_id :/^.+$/,
    client_id: /^.+$/,
    note_vaisselle : /^[0-5]+$/,
    note_proprete : /^[0-5]+$/,
    note_soin :/^[0-5]+$/,
    comment : /^[.]{0,300}$/ // Limité a 300 cacactère au max
};

const product_checker = {
    resto_id: /^.+$/,
    name_product: /^[A-Za-z-]+$/,
    dlc: /^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/
};

const inspection_sanitaire_checker = {
    date : /^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/
};

const objectif_checker = {
    description : /^[.]{600}$/
};

// ---- Fonctions utiles --- //

/**
 * Structure d'un client 
 * @param {Client} client Le client à vérifier
 * @param {boolean} check_all_client_keys on regarde toutes les clés
 * @returns {boolean} True c'est bon, False sinon
 */
const is_valid_client = (client, check_all_client_keys) => {
    let client_key = Object.keys(client).sort();
    let checker_keys = Object.keys(client_checker).sort();

    // regarder toutes les clé donnée par l'object bon format
    if(check_all_client_keys && !are_array_equal(client_key,checker_keys)){
        return false;
    }

    // Check the sub array of user keys
    if (!check_all_client_keys && !is_subarray_of(client_key, checker_keys)) {
        return false;
    }

    // on va regarder si c'est un utilisateur valide 
    let is_valid_client = client_key.reduce(
        (acc,key) => (client[key].match(client_checker[key])!= null) && acc,
        true
    );

    return is_valid_client;
};

/**
 * Structure resto 
 * @param {Resto} resto Le resto à vérifier
 * @param {boolean} check_all_resto_keys on regarde toutes les clés
 * @returns {boolean} True c'est bon, False sinon
 */
const is_valid_resto = (resto, check_all_resto_keys) => {
    let resto_keys = Object.keys(resto).sort();
    let checker_keys = Object.keys(check_all_resto_keys).sort();

    if(check_all_resto_keys && !are_array_equal(resto_keys,checker_keys)){
        return false;
    }

    if(!check_all_resto_keys && !is_subarray_of(resto_keys,checker_keys)){
        return false;
    }

    let is_valid_resto = resto_keys.reduce(
        (acc, key) => (resto[key].match(resto_checker[key]) != null ) && acc,
        true
    );

    return is_valid_resto;
};

/**
 * Structure note
 * @param {Note} note
 * @param {boolean} check_all_note_keys 
 * @returns {boolean}
 */
const is_valid_note = (note, check_all_note_keys) => {
    let note_keys = Object.keys(note).sort();
    let checker_keys = Object.keys(check_all_note_keys).sort();
    
    if(check_all_note_keys && !are_array_equal(note_keys,checker_keys)){
        return false;
    }
    
    if(!check_all_note_keys && !is_subarray_of(note_keys,checker_keys)){
        return false;
    }
    
    let is_valid_note = note_keys.reduce(
        (acc, key) => (note[key].match(note_checker[key]) != null ) && acc,
        true
    );
    
    return is_valid_note;
};

/**
 * Structure produit
 * @param {Product} product
 * @param {boolean} check_all_product_keys
 * @returns {boolean}
 */
const is_valid_product = (product, check_all_product_keys) => {
    let product_keys = Object.keys(product).sort();
    let checker_keys = Object.keys(check_all_product_keys).sort();
    
    if(check_all_product_keys && !are_array_equal(product_keys,checker_keys)){
        return false;
    }
    
    if(!check_all_product_keys && !is_subarray_of(product_keys,checker_keys)){
        return false;
    }
    
    let is_valid_product = product_keys.reduce(
        (acc, key) => (product[key].match(product_checker[key]) != null ) && acc,
        true
    );
    
    return is_valid_product;

};

/**
 * Structure Inspection
 * @param {Inspection_sanitaire} inspection 
 * @param {boolean} check_all_inspection_keys 
 * @returns {boolean}
 */
const is_valid_inspection = (inspection, check_all_inspection_keys) => {
    let inspection_keys = Object.keys(inspection).sort();
    let checker_keys = Object.keys(check_all_inspection_keys).sort();
    
    if(check_all_inspection_keys && !are_array_equal(inspection_keys,checker_keys)){
        return false;
    }
    
    if(!check_all_inspection_keys && !is_subarray_of(inspection_keys,checker_keys)){
        return false;
    }
    
    let is_valid_inspection = inspection_keys.reduce(
        (acc, key) => (inspection[key].match(inspection_sanitaire_checker[key]) != null ) && acc,
        true
    );
    
    return is_valid_inspection;

};

/**
 * Structure Objectif 
 * @param {Objectif} objectif 
 * @param {boolean} check_all_objectif_keys 
 * @returns {boolean}
 */
const is_valid_objectif = (objectif, check_all_objectif_keys) => {
    let objectif_keys = Object.keys(objectif).sort();
    let checker_keys = Object.keys(check_all_objectif_keys).sort();
    
    if(check_all_objectif_keys && !are_array_equal(objectif_keys,checker_keys)){
        return false;
    }
    
    if(!check_all_objectif_keys && !is_subarray_of(objectif_keys,checker_keys)){
        return false;
    }
    
    let is_valid_objectif = objectif_keys.reduce(
        (acc, key) => (objectif[key].match(objectif_checker[key]) != null ) && acc,
        true
    );
    
    return is_valid_objectif;

};

/**
 * On va checker si nos 2 réseaux sont égaux 
 * @param {Array} a le premier réseau
 * @param {Array} b le second réseau
 * @return {Boolean} Le réseau est-il égal ?
 */

const are_array_equal = (a,b) => JSON.stringify(a) == JSON.stringify(b);

/**
 * On va checker si un réseau et un sous réseau d'un autre 
 * @param {Array} a Le sous réseau
 * @param {Array} b Le réseau
 * @returns {boolean} a est un sous réseau de b ?
 */

const is_subarray_of = (a,b) => {
    for (let elem of a){
        // l'element n'est pas dans b
        if (b.indexOf(elem) == -1){
            return false;
        }
    }

    return true;
};

// ------- Fonction Export ------- //

const public_business = {
    // --------- Client -------- //
    /**
     * Récupère les clients de la base de donnée
     * @return {Client[]} un client 
     */
    get_all_client: async () => await data.get_all_client(),
    /**
     * @param {string} name_client
     * @returns {Client} un client
     */
    get_client: name_client => {return data.get_client(name_client)}, // on recupère les info utilisateur par son nom ou son pseudo

    /**
     * On essaye d'ajouter un utilisateur a la base de donnée et retourne un boolean
     * @param {Client} client le client à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_client: async client => {
        // on verifie si c'est la bonne structure
        if(!is_valid_client(client,true)){
            console.error("N'est pas valid client");
            return false
        }
        return await data.add_client(client);
    },

    /**
     * On essaye d'editer un utilisateur présent dans la base de donnée et on retourne un bool
     * @param {{id:string, to-edit:Client}} client
     * @returns {boolean} A-t-il bien été édité dans la base de donnée ?
     */
    edit_client: async client => {
        //on verifie si l'id et dans le client
        if(!("id" in client && "to_edit" in client)){
            console.log("je suis pas la ")
            return false;
        }

        //on verifie si l'id client est un string
        if(typeof client.id != "string"){
            return false;
        }

        //on verifie si la structure est correcte
        if(!is_valid_client(client.to_edit,false)){
            return false;
        }

        return await data.edit_client(client);
    },
    /**
     * On essaye de supprimer un client 
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} client Le client a suprimer
     * @returns {boolean} le client a-t-il était supprimé ?
     */
    delete_client: async client => {
        // On verifie si l'id est dans le client
        if(!("id" in client)){
            console.log("n'est pas dans le client");
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof client.id != "string"){
            return false;
        }
        return await data.delete_client(client.id);
    },

    // ------------------------ //
    // --------- Resto -------- //
    /**
     * Récupère les restos de la base de donnée
     * @return {Resto[]} un client 
     */
    get_all_resto: async () => await data.get_all_resto(),
    /**
     * @param {string} name_resto
     * @returns {Resto} un resto
     */
    get_resto: name_resto => {return data.get_resto(name_resto)}, // on recupère les infos resto par son nom
    /**
     * On essaye d'ajouter un resto a la base de donnée et retourne un boolean
     * @param {Resto} resto le resto à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_resto: async resto => {
        // on verifie si c'est la bonne structure
        // if(!is_valid_resto(resto,true)){
        //     console.error("N'est pas valid resto");
        //     return false
        // }
        return await data.add_resto(resto);
    },
    /**
    * On essaye d'editer un resto présent dans la base de donnée et on retourne un bool
    * @param {{id: string, to-edit: Resto}} resto
    * @returns {boolean} A-t-il bien été édité dans la base de donnée ?
    */
    edit_resto: async resto => {
        //on verifie si l'id et dans le client
        if(!("id" in resto && "to_edit" in resto)){
            return false;
        }

        //on verifie si l'id client est un string
        if(typeof resto.id != "string"){
            return false;
        }

        // //on verifie si la structure est correcte
        // if(!is_valid_resto(resto.to_edit,false)){
        //     return false;
        // }

        return await data.edit_resto(resto);
    },
    /**
     * On essaye de supprimer un resto 
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} resto Le resto a suprimer
     * @returns {boolean} le resto a-t-il était supprimé ?
     */
    delete_resto: async resto => {
        // On verifie si l'id est dans le client
        if(!("id" in resto)){
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof resto.id != "string"){
            return false;
        }
        return await data.delete_resto(resto.id);
    },

    // ------------------------- //
    // --------- Product ------- //
    /**
     * Récupère les produits de la base de donnée
     * @return {Product[]} un produit
     */
    get_all_product: async () => await data.get_all_product(),
    /**
     * On essaye d'ajouter un produit a la base de donnée et retourne un boolean
     * @param {Product} product le resto à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_product: async product => {
        // on verifie si c'est la bonne structure
        // if(!is_valid_product(product,true)){
        //     console.error("N'est pas valid product");
        //     return false
        // }
        return await data.add_product(product);
    },
    /**
    * On essaye d'editer un produit présent dans la base de donnée et on retourne un bool
    * @param {{id: string, to-edit: Product}} product
    * @returns {boolean} A-t-il bien été édité dans la base de donnée ?
    */
    edit_product: async product => {
        //on verifie si l'id et dans le client
        if(!("id" in product && "to_edit" in product)){
            return false;
        }

        //on verifie si l'id client est un string
        if(typeof product.id != "string"){
            return false;
        }

        //on verifie si la structure est correcte
        // if(!is_valid_product(product.to_edit,false)){
        //     return false;
        // }

        return await data.edit_product(product);
    },
    /**
     * On essaye de supprimer un produit
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} product Le produit a suprimer
     * @returns {boolean} le produit a-t-il était supprimé ?
    */
    delete_product: async product => {
        // On verifie si l'id est dans le client
        if(!("id" in product)){
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof product.id != "string"){
            return false;
        }
        return await data.delete_product(product.id);
    },

    // ---------------------- //
    // --------- Note ------- //
    /**
     * Récupère les Notes de la base de donnée
     * @return {Note[]} les notes
     */
    get_all_note: async () => await data.get_all_note(),
    /**
     * On essaye d'ajouter une note a la base de donnée et retourne un boolean
     * @param {Note} note la note à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_note: async note => {
        // on verifie si c'est la bonne structure
        // if(!is_valid_note(note,true)){
        //     console.error("N'est pas valid note");
        //     return false
        // }
        return await data.add_note(note);
    },
    /**
    * On essaye d'editer une note présent dans la base de donnée et on retourne un bool
    * @param {{id: string, to-edit: Note}} note
    * @returns {boolean} A-t-il bien été édité dans la base de donnée ?
    */
    edit_note: async note => {
        //on verifie si l'id et dans le client
        if(!("id" in note && "to_edit" in note)){
            return false;
        }

        //on verifie si l'id client est un string
        if(typeof note.id != "string"){
            return false;
        }

        //on verifie si la structure est correcte
        // if(!is_valid_note(note.to_edit,false)){
        //     return false;
        // }

        return await data.edit_note(note);
    },
    /**
     * On essaye de supprimer une note 
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} note La note a suprimer
     * @returns {boolean} la note a-t-il était supprimé ?
    */
    delete_note: async note => {
        // On verifie si l'id est dans le client
        if(!("id" in note)){
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof note.id != "string"){
            return false;
        }
        return await data.delete_note(note.id);
    },

    // ------------------------- //
    // --------- Favoris ------- //
    /**
     * Récupère les favoris de la base de donnée
     * @return {Favoris[]} les favoris
     */
    get_all_favoris: async () => await data.get_all_favoris(),
    /**
     * On essaye d'ajouter un favoris a la base de donnée et retourne un boolean
     * @param {Favoris} favoris le favoris à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_favoris: async favoris => {
        return await data.add_favoris(favoris);
    },
    /**
     * On essaye de supprimer un favoris 
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} favoris Le favoris a suprimer
     * @returns {boolean} le favoris a-t-il était supprimé ?
    */
    delete_favoris: async favoris => {
        // On verifie si l'id est dans le client
        if(!("id" in favoris)){
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof favoris.id != "string"){
            return false;
        }
        return await data.delete_favoris(favoris.id);
    },

    // ----------------------------- //
    // --------- Inspections Sanitaire ------- //
    /**
     * Récupère les inspections sanitaires de la base de donnée
     * @return {Inspection_sanitaire[]} les favoris
     */
    get_all_inspection: async () => await data.get_all_inspection(),
    /**
     * On essaye d'ajouter une inspection a la base de donnée et retourne un boolean
     * @param {Inspection_sanitaire} inspection l'inspection à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_inspection: async inspection => {
        // on verifie si c'est la bonne structure
        // if(!is_valid_inspection(inspection,true)){
        //     console.error("N'est pas valid inspection");
        //     return false
        // }
        return await data.add_inspection(inspection);
    },
    /**
    * On essaye d'editer une inspection présent dans la base de donnée et on retourne un bool
    * @param {{id: string, to-edit: Inspection_sanitaire}} inspection
    * @returns {boolean} A-t-il bien été édité dans la base de donnée ?
    */
    edit_inspection: async inspection => {
        //on verifie si l'id et dans le client
        if(!("id" in inspection && "to_edit" in inspection)){
            return false;
        }

        //on verifie si l'id client est un string
        if(typeof inspection.id != "string"){
            return false;
        }

        //on verifie si la structure est correcte
        // if(!is_valid_inspection(inspection.to_edit,false)){
        //     return false;
        // }

        return await data.edit_inspection(inspection);
    },
    /**
     * On essaye de supprimer une inspection 
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} inspection L'inspection a suprimer
     * @returns {boolean} l'inspection a-t-il était supprimé ?
    */
    delete_inspection: async inspection => {
        // On verifie si l'id est dans le client
        if(!("id" in inspection)){
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof inspection.id != "string"){
            return false;
        }
        return await data.delete_inspection(inspection.id);
    },

    // ---------------------------- //
    // --------- Objectif --------- //
    /**
     * Récupère les objectifs de la base de donnée
     * @return {Objectif[]} les favoris
     */
    get_all_objectif: async () => await data.get_all_objectif(),
    /**
     * On essaye d'ajouter un objectif a la base de donnée et retourne un boolean
     * @param {Objectif} objectif l'objectif à ajouter
     * @returns {boolean} A-t-il bien été ajouté ?
     */
    add_objectif: async objectif => {
        // on verifie si c'est la bonne structure
        // if(!is_valid_objectif(objectif,true)){
        //     console.error("N'est pas valid objectif");
        //     return false
        // }
        return data.add_objectif(objectif);
    },
    /**
    * On essaye d'editer un objectifprésent dans la base de donnée et on retourne un bool
    * @param {{id: string, to-edit: Objectif}} objectif
    * @returns {boolean} A-t-il bien été édité dans la base de donnée ?
    */
    edit_objectif: async objectif => {
        //on verifie si l'id et dans le client
        if(!("id" in objectif && "to_edit" in objectif)){
            return false;
        }

        //on verifie si l'id client est un string
        if(typeof objectif.id != "string"){
            return false;
        }

        //on verifie si la structure est correcte
        // if(!is_valid_objectif(objectif.to_edit,false)){
        //     return false;
        // }

        return data.edit_objectif(objectif);
    },
    /**
     * On essaye de supprimer un objectif 
     * en indicant si l'opération a bien été faites
     * @param {{id: string}} objectif L'objectif a suprimer
     * @returns {boolean} l'objectif a-t-il était supprimé ?
    */
    delete_objectif: async objectif => {
        // On verifie si l'id est dans le client
        if(!("id" in objectif)){
            return false;
        }

        //Veridie si l'id est bien un string
        if(typeof objectif.id != "string"){
            return false;
        }
        return data.delete_objectif(objectif.id);
    }
};

// ------ Export comme module ------ //
module.exports = public_business;
