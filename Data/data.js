//Rappel des tables de notre base de donnée 
/**
 * Table Client
 * @typedef {object} Client 
 * @property {string?} id id généré par mongodb
 * @property {string} first Prenom du client
 * @property {string} last Nom du client
 * @property {string} pseudo
 * @property {number} age
 * @property {string} email 
 * @property {string} password MDP du client en haché 
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Restaurant
 * @typedef {object} Resto
 * @property {string?} id id généré par mongodb
 * @property {string} name Nom de l'établissement
 * @property {string} adress Adresse de l'établissement
 * @property {string} type 
 * @property {string} description_resto Description de l'établissement
 * @property {string} email Email de l'etablissement
 * @property {string} password Mot de passe de l'établissement
 * @property {string} first_prop Prenom proprio
 * @property {string} last_prop Nom du proprio
 * @property {number} siret Numéro du siret
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Note
 * @typedef {object} Note
 * @property {string?} id id généré par mongodb
 * @property {string} resto_id id du rétaurant concerné par la note
 * @property {string} client_id id du client qui à mis la note
 * @property {number} note_vaisselle 
 * @property {number} note_proprete
 * @property {number} note_soin
 * @property {string} comment
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Favoris
 * @typedef {object} Favoris
 * @property {string?} id
 * @property {string} resto_id
 * @property {string} client_id
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table produit
 * @typedef {object} Product
 * @property {string?} id id généré par mongodb
 * @property {string} resto_id id du restaurant
 * @property {string} name_product
 * @property {string} dlc
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Inspection Sanitaire
 * @typedef {object} Inspection_sanitaire
 * @property {string?} id
 * @property {string} resto_id
 * @property {string} date
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Objectif
 * @typedef {object} Objectif
 * @property {string?} id
 * @property {string} inspection_id
 * @property {string} description
 * @property {string?} created_at The date of creation (generated by business)
 */

//---------- Importation des modules ----------//
const fs = require("fs");
const client = require("../Presentation/client")
const { markAsUntransferable } = require("worker_threads");
const { inspect } = require("util");
const { ObjectId } = require("mongodb");

//--------------- Initialisation des constantes de la base de donnée -----------------//
const db = client.db("rest-o-propre");
const CLIENTDATA = db.collection("Client") ;
const RESTODATA = db.collection("Restaurant");
const NOTEDATA = db.collection("Note");
const FAVDATA = db.collection("Favoris");
const PRODUCTDATA = db.collection("Product");
const INSPECTIONDATA = db.collection("Inspection_Sanitaire");
const OBJECTIFDATA = db.collection("Objectif");

//--------------- Fonctions utiles -----------------//
//Client ----------------------------------
/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Client[]} Tableau de tout les Utilisateur
 */
const read_clientdatabase_file = async () => await CLIENTDATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Client} client Tableau de tout les utilisateur
 */
const write_clientdatabase_file = client => CLIENTDATA.insertOne(client);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 * @param {{id:string, to-edit:Client}} client Tableau de tout les utilisateur
 */
const update_clientdatabase_file = (object,client) => CLIENTDATA.updateOne({_id:object},{$set: client.to_edit});
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_clientdatabase_file = object => CLIENTDATA.deleteOne({_id:object});

//Restaurant ---------------------------------------

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Resto[]} Tableau de tout les Utilisateur
 */
const read_restaurantdatabase_file = async () => await RESTODATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Resto} resto Tableau de tout les utilisateur
 */
const write_restaurantdatabase_file = resto => RESTODATA.insertOne(resto);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 * @param {{id:string, to-edit:Resto}} resto Tableau de tout les utilisateur
 */
const update_restaurantdatabase_file = (object,resto) => RESTODATA.updateOne({_id:object},{$set: resto.to_edit});
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_restaurantdatabase_file = object => RESTODATA.deleteOne({_id:object});

//Note -----------
/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Note[]} Tableau de tout les Utilisateur
 */
const read_notedatabase_file = async () => await NOTEDATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Note} note Tableau de tout les utilisateur
 */
const write_notedatabase_file = note => NOTEDATA.insertOne(note);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 * @param {{id:string, to-edit:Note}} note Tableau de tout les utilisateur
 */
const update_notedatabase_file = (object,note) => NOTEDATA.updateOne({_id:object},{$set: note.to_edit});
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_notedatabase_file = object => NOTEDATA.deleteOne({_id:object});

//Favoris ---------------------
/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Favoris[]} Tableau de tout les Utilisateur
 */
const read_favorisdatabase_file = async () => await FAVDATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Favoris} favoris Tableau de tout les utilisateur
 */
const write_favorisdatabase_file = favoris => FAVDATA.insertOne(favoris);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_favorisdatabase_file = object => FAVDATA.deleteOne({_id:object});

//Product -------------------
/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Product[]} Tableau de tout les Utilisateur
 */
const read_productdatabase_file = async () => await PRODUCTDATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Product} product Tableau de tout les utilisateur
 */
const write_productdatabase_file = product => PRODUCTDATA.insertOne(product);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 * @param {{id:string, to-edit:Product}} product Tableau de tout les utilisateur
 */
const update_productdatabase_file = (object,product) => PRODUCTDATA.updateOne({_id:object},{$set: product.to_edit});
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_productdatabase_file = object => PRODUCTDATA.deleteOne({_id:object});

//Inspection -------------------
/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Inspection_sanitaire[]} Tableau de tout les Utilisateur
 */
const read_inspectiondatabase_file = async () => await INSPECTIONDATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Inspection_sanitaire} inspection Tableau de tout les utilisateur
 */
const write_inspectiondatabase_file = inspection => INSPECTIONDATA.insertOne(inspection);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 * @param {{id:string, to-edit:Inspection_sanitaire}} inspection Tableau de tout les utilisateur
 */
const update_inspectiondatabase_file = (object,inspection) => INSPECTIONDATA.updateOne({_id:object},{$set: inspection.to_edit});
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_inspectiondatabase_file = object => INSPECTIONDATA.deleteOne({_id:object});

//Objectif -------------------
/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Objectif[]} Tableau de tout les Utilisateur
 */
const read_objectifdatabase_file = async () => await OBJECTIFDATA.find({}).toArray();
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Objectif} objectif Tableau de tout les utilisateur
 */
const write_objectifdatabase_file = objectif => OBJECTIFDATA.insertOne(objectif);
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 * @param {{id:string, to-edit:Objectif}} objectif Tableau de tout les utilisateur
 */
const update_objectifdatabase_file = (object,objectif) => OBJECTIFDATA.updateOne({_id:object},{$set: objectif.to_edit});
/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {ObjectId} object l'id 
 */
const delete_objectifdatabase_file = object => OBJECTIFDATA.deleteOne({_id:object});

//-------------------- Fonctions Public --------------//

const data_public = {
    //Client -------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Client[]} Tableau de tout les utilisateurs
      */
    get_all_client: async () => await read_clientdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Client} client Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_client: async client => {
      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      client.created_at = new Date().toUTCString();
      
      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_clientdatabase_file(client);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Client}} client utilisateur a editer
    * @returns {boolean} 
    */
    edit_client: async client => {
      const id = new ObjectId(client.id);
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           update_clientdatabase_file(id,client);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_client: async id => {

    const _id = new ObjectId(id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         delete_clientdatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Reto ---------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Resto[]} Tableau de tout les utilisateurs
      */
    get_all_resto: async () => await read_restaurantdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Resto} resto Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_resto: async resto => {
      //Ajout des infos restos
      //client.id = get_lastclient_index(client) + 1;
      resto.created_at = new Date().toUTCString();

      //Ecrit un resto et retourne une érreur si jamais 
      try {
           write_restaurantdatabase_file(resto);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Resto}} resto utilisateur a editer
    * @returns {boolean} 
    */
    edit_resto: async resto => {
     const id = new ObjectId(client.id);
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           update_restaurantdatabase_file(id,resto);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_resto: async id => {
     const _id = new ObjectId(id);
    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         delete_restaurantdatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Note ---------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Note[]} Tableau de tout les utilisateurs
      */
    get_all_note: async () => await read_notedatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Note} note Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_note: async note => {
      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      note.created_at = new Date().toUTCString();

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_notedatabase_file(note);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Note}} note utilisateur a editer
    * @returns {boolean} 
    */
    edit_note: async note => {
      const id = new ObjectId(note.id)
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           update_notedatabase_file(id,note);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_note: async id => {
     const _id = new ObjectId(id);
    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         delete_notedatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Favoris ------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Favoris[]} Tableau de tout les utilisateurs
      */
    get_all_favoris: async () => await read_favorisdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Favoris} favoris Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_favoris: async favoris => {
      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      favoris.created_at = new Date().toUTCString();

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_favorisdatabase_file(favoris);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_favoris: async id => {
     const _id = new ObjectId(id)
    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         delete_favorisdatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Product ------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Product[]} Tableau de tout les utilisateurs
      */
    get_all_product: async () => await read_productdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Product} product Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_product: async product => {
      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      product.created_at = new Date().toUTCString();

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_productdatabase_file(product);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Product}} product utilisateur a editer
    * @returns {boolean} 
    */
    edit_product: async product => {
     const id = new ObjectId(product.id);
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           update_productdatabase_file(id,product);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_product: async id => {
     const _id = new ObjectId(id);
    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         await delete_productdatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Inspection Sanitaire -----
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Inspection_sanitaire[]} Tableau de tout les utilisateurs
      */
    get_all_inspection: async () => await read_inspectiondatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Inspection_sanitaire} inspection Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_inspection: async inspection => {
      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      inspection.created_at = new Date().toUTCString();

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_inspectiondatabase_file(inspection);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Inspection_sanitaire}} inspection utilisateur a editer
    * @returns {boolean} 
    */
    edit_inspection: async inspection => {
      const id = new ObjectId(inspection.id);
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           update_inspectiondatabase_file(id,inspection);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
  delete_inspection: async id => {
     const _id = new ObjectId(id);
    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         await delete_inspectiondatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Objectif -----------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Objectif[]} Tableau de tout les utilisateurs
      */
    get_all_objectif: async () => await read_objectifdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Objectif} objectif Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_objectif: async objectif => {
      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      objectif.created_at = new Date().toUTCString();

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_objectifdatabase_file(objectif);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Objectif}} objectif utilisateur a editer
    * @returns {boolean} 
    */
    edit_objectif: async objectif => {
      const id = new ObjectId(objectif.id)
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           update_objectifdatabase_file(id,objectif);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_objectif: async id => {
     const _id = new ObjectId(id)
    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         delete_objectifdatabase_file(_id);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    }
}

module.exports = data_public;