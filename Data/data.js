//Rappel des tables de notre base de donnée 
/**
 * Table Client
 * @typedef {object} Client 
 * @property {string?} id id généré par mongodb
 * @property {string} firts Prenom du client
 * @property {string} last Nom du client
 * @property {string} pseudo
 * @property {number} age
 * @property {string} email 
 * @property {string?} password MDP du client en haché 
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Restaurant
 * @typedef {object} Resto
 * @property {string?} id id généré par mongodb
 * @property {string} name Nom de l'établissement
 * @property {string} adress Adresse de l'établissement
 * @property {int} type 
 * @property {string} description_resto Description de l'établissement
 * @property {Array} photo_uuid Tableau contenant les adresses des photos
 * @property {string} email Email de l'etablissement
 * @property {string?} password Mot de passe de l'établissement
 * @property {string} first_prop Prenom proprio
 * @property {string} last_prop Nom du proprio
 * @property {string} paper_id Pièce d'identité
 * @property {number} siret Numéro du siret
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Note
 * @typedef {object} Note
 * @property {string?} id id généré par mongodb
 * @property {number} resto_id id du rétaurant concerné par la note
 * @property {number} client_id id du client qui à mis la note
 * @property {number} note_vaisselle 
 * @property {number} note_propreté
 * @property {number} note_soin
 * @property {string} comment
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Favoris
 * @typedef {object} Favoris
 * @property {string?} id
 * @property {number} resto_id
 * @property {number} client_id
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table produit
 * @typedef {object} Product
 * @property {string?} id id généré par mongodb
 * @property {number} resto_id id du restaurant
 * @property {string} name_product
 * @property {string} dlc
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Inspection Sanitaire
 * @typedef {object} Inspection_sanitaire
 * @property {string?} id
 * @property {number} resto_id
 * @property {string} date
 * @property {string?} created_at The date of creation (generated by business)
 */

/**
 * Table Objectif
 * @typedef {object} Objectif
 * @property {string?} id
 * @property {number} inspection_id
 * @property {string} description
 * @property {string?} created_at The date of creation (generated by business)
 */

//---------- Importation des modules ----------//
const fs = require("fs");
const client = require("../Presentation/client")
const { markAsUntransferable } = require("worker_threads");
const { inspect } = require("util");

//--------------- Initialisation des constantes de la base de donnée -----------------//
const db = client.db("rest-o-propre");
const CLIENTDATA = db.collection("Client") ;
const RESTODATA = db.collection("Restaurant");
const NOTEDATA = db.collection("Note");
const FAVDATA = db.collection("Favoris");
const PRODUCTDATA = db.collection("Product");
const INSPECTIONDATA = db.collection("Inspection_Sanitaire");
const OBJECTIFDATA = db.collection("Objectif");

//--------------- Fonctions utiles -----------------//
//Client ----------------------------------
/**
 * Récupération du dernier index donné
 * @param {Client[]} client Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastClient_index = client => Math.max(...client.map(client => client.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Client[]} Tableau de tout les Utilisateur
 */
const clientArray = CLIENTDATA.find({}).toArray();
const read_clientdatabase_file = () => {try {
     // Parse a JSON
     JSON.parse(clientArray); 
 } catch{
     // You can read e for more info
     // Let's assume the error is that we already have parsed the clienttable
     // So just return that
     clientArray
 };};

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Client[]} client Tableau de tout les utilisateur
 */
const write_clientdatabase_file = client => CLIENTDATA.insertMany(client);

//Restaurant ---------------------------------------
/**
 * Récupération du dernier index donné
 * @param {Resto[]} resto Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastresto_index = resto => Math.max(...resto.map(resto => resto.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Resto[]} Tableau de tout les Utilisateur
 */
const restoArray = RESTODATA.find({}).toArray();
const read_restaurantdatabase_file = () => JSON.parse(restoArray);

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Resto[]} restos Tableau de tout les utilisateur
 */
const write_restaurantdatabase_file = restos => RESTODATA.insertMany(restos);

//Note ----------------------------
/**
 * Récupération du dernier index donné
 * @param {Note[]} note Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastnote_index = note => Math.max(...note.map(note => note.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Note[]} Tableau de tout les Utilisateur
 */
const noteArray = NOTEDATA.find({}).toArray();
const read_notedatabase_file = () => JSON.parse(noteArray);

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Note[]} notes Tableau de tout les utilisateur
 */
const write_notedatabase_file = notes => NOTEDATA.insertMany(notes);

//Favoris ---------------------
/**
 * Récupération du dernier index donné
 * @param {Favoris[]} favoris Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastfavoris_index = favoris => Math.max(...favoris.map(favoris => favoris.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Favoris[]} Tableau de tout les Utilisateur
 */
const favorisArray = FAVDATA.find({}).toArray();
const read_favorisdatabase_file = () => JSON.parse(favorisArray);

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Favoris[]} favoris Tableau de tout les utilisateur
 */
const write_favorisdatabase_file = favoris => FAVDATA.insertMany(favoris);

//Product --------------------------
/**
 * Récupération du dernier index donné
 * @param {Product[]} product Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastproduct_index = product => Math.max(...product.map(product => product.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Product[]} Tableau de tout les Utilisateur
 */
const productArray = PRODUCTDATA.find({}).toArray();
const read_productdatabase_file = () => JSON.parse(productArray);

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Product[]} products Tableau de tout les utilisateur
 */
const write_productdatabase_file = products => PRODUCTDATA.insertMany(products);

//Inspection sanitaire ---------------------
/**
 * Récupération du dernier index donné
 * @param {Inspection_sanitaire[]} inspection Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastinspection_index = inspection => Math.max(...inspection.map(inspection => inspection.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Inspection_sanitaire[]} Tableau de tout les Utilisateur
 */
const inspectionArray = INSPECTIONDATA.find({}).toArray();
const read_inspectiondatabase_file = () => JSON.parse(inspectionArray);

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Inspection_sanitaire[]} inspection Tableau de tout les utilisateur
 */
const write_inspectiondatabase_file = inspection => INSPECTIONDATA.insertMany(inspection);

//Objectif -----------------------
/**
 * Récupération du dernier index donné
 * @param {Objectif[]} objectif Tableau de tout les utilisateurs
 * @returns {number} Le dernier utilisateur 
 */
const get_lastobjectif_index = objectif => Math.max(...objectif.map(objectif => objectif.id),0);

/**
 * Récupération de tout les utilisateurs de la base de donnée
 * @returns {Objectif[]} Tableau de tout les Utilisateur
 */
const objectifArray = OBJECTIFDATA.find({}).toArray();
const read_objectifdatabase_file = () => JSON.parse(objectifArray);

/**
 * Ecrit un utilisateur dans la base de donnée 
 * @param {Objectif[]} objectif Tableau de tout les utilisateur
 */
const write_objectifdatabase_file = objectif => OBJECTIFDATA.insertMany(objectif);

//-------------------- Fonctions Public --------------//

const data_public = {
    //Client -------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Client[]} Tableau de tout les utilisateurs
      */
    get_all_client: () => read_clientdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Client} client Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_client: client => {
      let clients;

      // On lis les clients de la base et renvoie faux si erreur
      try{
           clients = read_clientdatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      client.created_at = new Date().toUTCString();
      
      //Ajout d'un client dans le tableau 
      clients.push(client);

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_clientdatabase_file(clients);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Client}} client utilisateur a editer
    * @returns {boolean} 
    */
    edit_client: client => {
      let clients;
      
      // lis un utilisateur et retourn faux su erreur 
      try {
       clients = read_clientdatabase_file();
   
      } catch {
        console.error("n'as pas pu lire dans la base de donnée");
        return false;
      }
   
      // Get l'index
      let client_index = -1;
      for(let i=0; i < clients.length; i++){
           if(clients[i].id == client.id){
               client_index = i;
           }
      }
   
      // User not found
      if(client_index == -1){
           return false;
      }
   
      //Edit user
      for(let key in client.to_edit){
           clients[client_index][key] = client.to_edit[key];
      }
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           write_clientdatabase_file(clients);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_client: id => {
    let clients;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         clients = read_clientdatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(clients.map(client => client.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    clients = clients.filter(client => client.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_clientdatabase_file(clients);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Reto ---------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Resto[]} Tableau de tout les utilisateurs
      */
    get_all_resto: () => read_restaurantdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Resto} resto Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_resto: resto => {
      let restos;

      // On lis les restos de la base et renvoie faux si erreur
      try{
           resto = read_restaurantdatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos restos
      //client.id = get_lastclient_index(client) + 1;
      resto.created_at = new Date().toUTCString();
      
      //Ajout d'un resto dans le tableau 
      restos.push(resto);

      //Ecrit un resto et retourne une érreur si jamais 
      try {
           write_restaurantdatabase_file(restos);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Resto}} resto utilisateur a editer
    * @returns {boolean} 
    */
    edit_resto: resto => {
      let restos;
      
      // lis un utilisateur et retourn faux su erreur 
      try {
       restos = read_restodatabase_file();
   
      } catch {
        console.error("n'as pas pu lire dans la base de donnée");
        return false;
      }
   
      // Get l'index
      let resto_index = -1;
      for(let i=0; i < restos.length; i++){
           if(restos[i].id == resto.id){
               resto_index = i;
           }
      }
   
      // User not found
      if(resto_index == -1){
           return false;
      }
   
      //Edit user
      for(let key in resto.to_edit){
           restos[resto_index][key] = resto.to_edit[key];
      }
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           write_restodatabase_file(restos);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_resto: id => {
    let restos;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         restos = read_restaurantdatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(restos.map(resto => resto.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    restos = restos.filter(resto => resto.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_restaurantdatabase_file(restos);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Note ---------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Note[]} Tableau de tout les utilisateurs
      */
    get_all_note: () => read_notedatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Note} note Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_note: note => {
      let notes;

      // On lis les clients de la base et renvoie faux si erreur
      try{
           notes = read_notedatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      note.created_at = new Date().toUTCString();
      
      //Ajout d'un client dans le tableau 
      notes.push(note);

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_notedatabase_file(note);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Note}} note utilisateur a editer
    * @returns {boolean} 
    */
    edit_note: note => {
      let notes;
      
      // lis un utilisateur et retourn faux su erreur 
      try {
       notes = read_notedatabase_file();
   
      } catch {
        console.error("n'as pas pu lire dans la base de donnée");
        return false;
      }
   
      // Get l'index
      let note_index = -1;
      for(let i=0; i < notes.length; i++){
           if(notes[i].id == note.id){
               note_index = i;
           }
      }
   
      // User not found
      if(note_index == -1){
           return false;
      }
   
      //Edit user
      for(let key in note.to_edit){
           notes[note_index][key] = note.to_edit[key];
      }
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           write_notedatabase_file(notes);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_note: id => {
    let notes;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         notes = read_notedatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(notes.map(note => note.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    notes = notes.filter(note => note.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_notedatabase_file(notes);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Favoris ------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Favoris[]} Tableau de tout les utilisateurs
      */
    get_all_favoris: () => read_favorisdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Favoris} favoris Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_favoris: favoris => {
      let favoriss;

      // On lis les clients de la base et renvoie faux si erreur
      try{
           favoriss = read_favorisdatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      favoris.created_at = new Date().toUTCString();
      
      //Ajout d'un client dans le tableau 
      favoriss.push(favoris);

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_favorisdatabase_file(favoriss);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_favoris: id => {
    let favoriss;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         favoriss = read_favorisdatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(favoriss.map(favoris => favoris.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    favoriss = favoriss.filter(favoris => favoris.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_favorisdatabase_file(favoriss);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Product ------------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Product[]} Tableau de tout les utilisateurs
      */
    get_all_product: () => read_productdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Product} product Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_product: product => {
      let products;

      // On lis les clients de la base et renvoie faux si erreur
      try{
           products = read_productdatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      product.created_at = new Date().toUTCString();
      
      //Ajout d'un client dans le tableau 
      products.push(product);

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_productdatabase_file(products);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Product}} product utilisateur a editer
    * @returns {boolean} 
    */
    edit_product: product => {
      let products;
      
      // lis un utilisateur et retourn faux su erreur 
      try {
       products = read_productdatabase_file();
   
      } catch {
        console.error("n'as pas pu lire dans la base de donnée");
        return false;
      }
   
      // Get l'index
      let product_index = -1;
      for(let i=0; i < products.length; i++){
           if(products[i].id == product.id){
               product_index = i;
           }
      }
   
      // User not found
      if(product_index == -1){
           return false;
      }
   
      //Edit user
      for(let key in product.to_edit){
           products[product_index][key] = product.to_edit[key];
      }
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           write_productdatabase_file(products);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_product: id => {
    let products;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         products = read_productdatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(products.map(product => product.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    products = products.filter(product => product.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_productdatabase_file(products);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Inspection Sanitaire -----
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Inspection_sanitaire[]} Tableau de tout les utilisateurs
      */
    get_all_inspection: () => read_inspectiondatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Inspection_sanitaire} inspection Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_inspection: inspection => {
      let inspections;

      // On lis les clients de la base et renvoie faux si erreur
      try{
           inspections = read_inspectiondatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      inspection.created_at = new Date().toUTCString();
      
      //Ajout d'un client dans le tableau 
      inspections.push(client);

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_inspectiondatabase_file(inspections);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Inspection_sanitaire}} inspection utilisateur a editer
    * @returns {boolean} 
    */
    edit_inspection: inspection => {
      let inspections;
      
      // lis un utilisateur et retourn faux su erreur 
      try {
       inspections = read_inspectiondatabase_file();
   
      } catch {
        console.error("n'as pas pu lire dans la base de donnée");
        return false;
      }
   
      // Get l'index
      let inspection_index = -1;
      for(let i=0; i < inspections.length; i++){
           if(inspections[i].id == inspection.id){
               inspection_index = i;
           }
      }
   
      // User not found
      if(inspection_index == -1){
           return false;
      }
   
      //Edit user
      for(let key in inspection.to_edit){
           inspections[inspection_index][key] = inspection.to_edit[key];
      }
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           write_inspectiondatabase_file(inspections);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
  delete_inspection: id => {
    let inspections;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         inspections = read_inspectiondatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(inspections.map(inspection => inspection.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    inspections = inspections.filter(inspection => inspection.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_inspectiondatabase_file(inspections);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    },
    //Objectif -----------------
    /**
      * Récupère tout les clients de la base de donnée 
      * @returns {Objectif[]} Tableau de tout les utilisateurs
      */
    get_all_objectif: () => read_objectifdatabase_file(),
    /**
      * Ajout d'un client a la base de donnée
      * @param {Objectif} objectif Le client a ajouter (vérifié)
      * @return {boolean} A-t-il était ajouté ?
      */
    add_objectif: objectif => {
      let objectifs;

      // On lis les clients de la base et renvoie faux si erreur
      try{
           objectifs = read_objectifdatabase_file();
      } catch{
           console.error("Ne peut pas lire depuis la base de donnée");
           console.log("Ne peut pas lire depuis la base de donnée");
           return false;
      }

      //Ajout des infos client
      //client.id = get_lastclient_index(client) + 1;
      objectif.created_at = new Date().toUTCString();
      
      //Ajout d'un client dans le tableau 
      objectifs.push(objectif);

      //Ecrit un client et retourne une érreur si jamais 
      try {
           write_objectifdatabase_file(objectifs);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           console.log("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
    },
    /**
    * Editer un utilisateur de la database
    * @param {{id: string, to_edit: Objectif}} objectif utilisateur a editer
    * @returns {boolean} 
    */
    edit_objectif: objectif => {
      let objectifs;
      
      // lis un utilisateur et retourn faux su erreur 
      try {
       objectifs = read_objectifdatabase_file();
   
      } catch {
        console.error("n'as pas pu lire dans la base de donnée");
        return false;
      }
   
      // Get l'index
      let objectif_index = -1;
      for(let i=0; i < objectifs.length; i++){
           if(objectifs[i].id == objectif.id){
               objectif_index = i;
           }
      }
   
      // User not found
      if(objectif_index == -1){
           return false;
      }
   
      //Edit user
      for(let key in objectif.to_edit){
           objectifs[objectif_index][key] = objectif.to_edit[key];
      }
 
      //Ecrit l'utilisateur et retourne une érreur si jamais 
      try {
           write_objectifdatabase_file(objectifs);
       } catch {
           console.error("Ne peut pas écrire dans la base de donnée");
           return false;
       }
       
       return true;
      
    },
    /**
   * suprime un utilisateur depuis la base de donnée
   * @param {string} id l'id de l'utilisateur a supprimer
   * @returns {boolean} Est-il suprimé ?
   */
    delete_objectif: id => {
    let objectifs;

    // Lis les utilisateurs et retourne faux si impossible
    try{
         objectifs = read_objectifdatabase_file();
    } catch{
         console.error("Ne peut pas lire depuis la base de donnée");
         return false;
    }

    //Regarde si l'id est dans users
    if(objectifs.map(objectif => objectif.id).indexOf(id) == -1){
         return false;
    }

    //Supprime l'utilisateur
    objectifs = objectifs.filter(objectif => objectif.id != id);

    //Ecrit l'utilisateur et retourne une érreur si jamais 
    try {
         write_objectifdatabase_file(objectifs);
     } catch {
         console.error("Ne peut pas écrire dans la base de donnée");
         return false;
     }
     
     return true;
    }
}

module.exports = data_public;